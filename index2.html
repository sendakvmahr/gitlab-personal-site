<!DOCTYPE HTML> 
<head> 
	<meta http-equiv="content-type" content="text/html; charset=utf-8"> 
    <link rel="icon" type="image/png" href="./images/favicon.png?" />
	<title>Sendak Vivian Mahr</title> 
	<script type="text/javascript" src="./js/util.js"></script>
</head>
<body>
	<div id="canvasContainer" style="
		position: absolute;
		top: 0;bottom: 0; ;left: 0; right: 0; 
		/*background: url('./images/Wire Loop.png');*/
		background-size: 192px;
		background-repeat: repeat-x;
		image-rendering: optimizeSpeed;             /* STOP SMOOTHING, GIVE ME SPEED  */
		image-rendering: -moz-crisp-edges;          /* Firefox                        */
		image-rendering: -o-crisp-edges;            /* Opera                          */
		image-rendering: -webkit-optimize-contrast; /* Chrome (and eventually Safari) */
		image-rendering: pixelated; /* Chrome */
		image-rendering: optimize-contrast;         /* CSS3 Proposed                  */
		-ms-interpolation-mode: nearest-neighbor;   /* IE8+                           */

	"></div>
    <canvas id="canvas"></canvas>
	<script id="vshader2d" type="vshader">
	    // with texture
	    uniform mat3 u_matrix;
	    attribute vec2 a_position;
	    attribute vec2 a_texCoord;
	    varying vec2 v_texCoord;    
	    void main() {
	        gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
	        v_texCoord = a_texCoord;
	    }
	</script>

	<script id="fgshader2d" type="fgshader">
	    // with texture
	    precision mediump float;
	    uniform sampler2D u_image;
	    uniform vec2 u_textureSize;
	    varying vec2 v_texCoord;

	    void main() {
	        vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
	        gl_FragColor =  texture2D(u_image, v_texCoord);
	    }
	</script>


    <script id="luminosityDiff" type="fgshader">
        precision mediump float;
        uniform sampler2D u_image;
        uniform vec2 u_textureSize;
        uniform mat4 u_palette0;
        uniform mat4 u_palette1;
        uniform mat4 u_palette2;
        uniform mat4 u_palette3;
        uniform mat4 u_luminosity;
        
        varying vec2 v_texCoord;

        void main() {
            vec4 sampledColor = texture2D(u_image, v_texCoord);
            float lumens = 0.2126 * sampledColor.r + 0.7152 * sampledColor.g + 0.0722 * sampledColor.b;

            float distance0 = distance(lumens, u_luminosity[0][0]);
            float distance1 = distance(lumens, u_luminosity[0][1]);
            float distance2 = distance(lumens, u_luminosity[0][2]);
            float distance3 = distance(lumens, u_luminosity[0][3]);
            float distance4 = distance(lumens, u_luminosity[1][0]);
            float distance5 = distance(lumens, u_luminosity[1][1]);
            float distance6 = distance(lumens, u_luminosity[1][2]);
            float distance7 = distance(lumens, u_luminosity[1][3]);
            float distance8 = distance(lumens, u_luminosity[2][0]);
            float distance9 = distance(lumens, u_luminosity[2][1]);
            float distance10 = distance(lumens, u_luminosity[2][2]);
            float distance11 = distance(lumens, u_luminosity[2][3]);
            float distance12 = distance(lumens, u_luminosity[3][0]);
            float distance13 = distance(lumens, u_luminosity[3][1]);
            float distance14 = distance(lumens, u_luminosity[3][2]);
            float distance15 = distance(lumens, u_luminosity[3][3]);

            
            float currentDistance = distance0;
            gl_FragColor = u_palette0[0];
            if (distance1 < currentDistance) { currentDistance = distance1; gl_FragColor = u_palette0[1];}
            if (distance2 < currentDistance) { currentDistance = distance2; gl_FragColor = u_palette0[2];}
            if (distance3 < currentDistance) { currentDistance = distance3; gl_FragColor = u_palette0[3];}
            
            if (distance4 < currentDistance) { currentDistance = distance4; gl_FragColor = u_palette1[0];}
            if (distance5 < currentDistance) { currentDistance = distance5; gl_FragColor = u_palette1[1];}
            if (distance6 < currentDistance) { currentDistance = distance6; gl_FragColor = u_palette1[2];}
            if (distance7 < currentDistance) { currentDistance = distance7; gl_FragColor = u_palette1[3];}
            
            if (distance8 < currentDistance) { currentDistance = distance8; gl_FragColor = u_palette2[0];}
            if (distance9 < currentDistance) { currentDistance = distance9; gl_FragColor = u_palette2[1];}
            if (distance10 < currentDistance) { currentDistance = distance10; gl_FragColor = u_palette2[2];}
            if (distance11 < currentDistance) { currentDistance = distance11; gl_FragColor = u_palette2[3];}
            
            if (distance12 < currentDistance) { currentDistance = distance12; gl_FragColor = u_palette3[0];}
            if (distance13 < currentDistance) { currentDistance = distance13; gl_FragColor = u_palette3[1];}
            if (distance14 < currentDistance) { currentDistance = distance14; gl_FragColor = u_palette3[2];}
            if (distance15 < currentDistance) { currentDistance = distance15; gl_FragColor = u_palette3[3];}
        }
    </script>
    

    <script>
function calcLuminosity(r, g, b) {
    return (0.2126 * r) + (0.7152 * g) + (0.0722 * b);
}


function main() {
    var images = {
        //            loader: "http://vivianmahr.com/images/stars.png"
        loader: "https://cdn.discordapp.com/icons/578316321758904320/2092062007b5a71b5a68e25a50375835.webp"
        //loader: "https://i.imgur.com/zCQSVFV.jpg"
    }

    function renderStart(passInImages) {
        var canvas = document.getElementById("canvas");
        var gl = canvas.getContext("webgl", {
            antialias: false,
            premultipliedAlpha: true
        });
        if (!gl) {
            return;
        }
        var rect = canvas.getBoundingClientRect();
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
        gl.enable(gl.BLEND)
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        gl.clearColor(0, 0, 0, 0);
        resize(gl);
        var program = wgl.shadersToProgram(gl, document.getElementById("vshader2d").text, document.getElementById("luminosityDiff").text);

        var setters = wgl.createSetters(gl, program);
        var canvasImages = {
            loader: {
                img: passInImages.loader,
                ctx: "",
                canvas: "",
                texture: ""
            }
        }
        wgl.loadCanvasImages(gl, canvasImages);
        //		wgl.loadCanvasText(gl, canvasImages, canvas);

        var objects = [{
                scale: [4.5, 4.5],
                translation: [(canvas.clientWidth - canvasImages.loader.canvas.width) / 2, (canvas.clientHeight - canvasImages.loader.canvas.height) / 2],
                rotation: 45 * Math.PI / 180,
                program: program,
                texture: canvasImages.loader,
                height: canvasImages.loader.canvas.height,
                width: canvasImages.loader.canvas.width,
                primitive: gl.TRIANGLES,
                offset: 0,
                count: 6,
            },
            {
                label: "textElement",
                scale: [1, 1],
                translation: [0, 0],
                rotation: 0,
                program: program,
                texture: {
                    text: `Hello! I'm Sendak Vivian Mahr. What would you like to know?`,
                    /*I heard you're a programmer. 
						Can I see some site you've designed?
						Did you draw all this?
						I want to talk about something else. `, */
                    ctx: null,
                    canvas: null,
                    width: 1, // fraction of the main canvas it should take up
                    texture: null,
                    color: "#005500",
                    // there should be a backup pixel font if it falls below a certian height. I don't even care, normal fonts are butt ugly resized. 
                    font: "40px sans-serif",
                    lineHeight: 40
                },
                height: canvas.clientHeight, // how big it it on client
                width: canvas.clientWidth, // how big it it on client
                primitive: gl.TRIANGLES,
                offset: 0,
                count: 6,
                isHover: false,
                onHover: function() {
                    this.texture.bgColor = "#FF0000";
                    wgl.reloadCanvasText(gl, this, canvas);
                },
                offHover: function() {
                    this.texture.bgColor = null;
                    wgl.reloadCanvasText(gl, this, canvas);
                },
                onClick: function() {
                    console.log("this element has been clicked");
                }
            }
        ];
        wgl.loadCanvasText(gl, objects, canvas);


        function pointCollision(obj, x, y) {
            // doesn't take rotation or scale into account
            return (x <= obj.translation[0] + obj.width && x >= obj.translation[0]) && (y <= obj.translation[1] + obj.height && y >= obj.translation[1])
        }

        function mousePosition(event, canvas) {
            let rect = canvas.getBoundingClientRect();
            return [event.clientX - rect.left, event.clientY - rect.top];
        }
        document.getElementById("canvasContainer").addEventListener('click', function(e) {
            let [elx, ely] = mousePosition(e, canvas);
            for (let o in objects) {
                let obj = objects[o];
                if (obj.onClick !== undefined) {
                    if (pointCollision(obj, elx, ely)) {
                        obj.onClick();
                    }
                }
            }
        });
        document.getElementById("canvasContainer").addEventListener("mousemove", function(e) {

            let [elx, ely] = mousePosition(e, canvas);
            for (let o in objects) {
                let obj = objects[o];
                if (obj.onHover !== undefined) {
                    let collide = pointCollision(obj, elx, ely);
                    if (!obj.isHover && collide) {
                        obj.onHover();
                        obj.isHover = !obj.isHover;
                    } else if (obj.isHover && !collide) {
                        obj.offHover();
                        obj.isHover = !obj.isHover;
                    }
                }
            }
        });

        function resize(gl) {
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            // hehe
            canvas.width = canvas.clientWidth / 4;
            canvas.height = canvas.clientHeight / 4;
            //wgl.resizeCanvasToDisplaySize(gl.canvas);
        };

        var counter = 0;
        var palettes = [
        	[
				0,0,0,1,
				1,1,1,1,
				0.3953799176397176, 0.27628540112228817, 0.21932623834549592, 1,
				0.7094503110877731, 0.7679715163719505, 0.8718641650469261, 1,
			], 
			[
				0.3190165897171239, 0.279010264177895, 0.759049205017336, 1,
				0.7113594655791933, 0.8308911528522663, 0.13946166664652482, 1,
				0.8353157607669144, 0.5454495305810343, 0.3919509248339327, 1,
				0.7850384190827203, 0.45928561369173637, 0.31719540362545795, 1,
			],
			[
				0.4799374647641642, 0.8311399988803204, 0.1317888856538847, 1,
				0.06848251468564415, 0.43741428141659955, 0.04648827957505419, 1,
				0.8685688831680225, 0.8108286924880623, 0.8265540361523411, 1,
				0.4940587311002901, 0.6484714049472903, 0.41227493980532004, 1
			],
			[
				0.014286213418056581, 0.20435083534177123, 0.7292034051016667, 1,
				0.8887428400200774, 0.4191383812501698, 0.3635952527028302, 1,
				0.5356493762329001, 0.09527064021706055, 0.5312217231910571, 1,
				0.6856086498427222, 0.9719182310479099, 0.03856667531801006, 1
			]
        ]
        var luminosity = [];
		for (let p in palettes) {
			let palette = palettes[p];
			for (let n = 0; n<palette.length; n+=4) {
				luminosity.push(calcLuminosity(palette[n], palette[n+1], palette[n+2]));
			}
		}


        function clear(gl) {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }

        draw();

        function draw(name) {
            if (canvas.matches(':hover')) {
                window.requestAnimationFrame(draw);
                return;
            }
            // Necessary start of draw loop
            resize(gl);
            clear(gl);
            let unis = {},
                atts = {},
                matrix = wgl.m3.projection(gl.canvas.clientWidth, gl.canvas.clientHeight);

            // Calculations to be run every loop, ~ 60 fps
            //objects[1].rotation += Math.PI/180;
            objects[0].rotation -= Math.PI / 180;

            // Render every object. Should be a tree but we're not doing scenegraphs yet
            for (let o in objects) {
                let obj = objects[o];
                gl.useProgram(obj.program);
                unis.u_textureSize = [obj.texture.canvas.width, obj.texture.canvas.height];
                unis.u_luminosity = luminosity;
                unis.u_palette0 = palettes[0];
                unis.u_palette1 = palettes[1];
                unis.u_palette2 = palettes[2];
                unis.u_palette3 = palettes[3];


                let matrix2 = wgl.m3.translate(matrix, obj.translation[0], obj.translation[1]);
                matrix2 = wgl.m3.translate(matrix2, obj.width / 2, obj.height / 2);
                matrix2 = wgl.m3.rotate(matrix2, obj.rotation);
                matrix2 = wgl.m3.scale(matrix2, obj.scale[0], obj.scale[1]);
                unis.u_matrix = wgl.m3.translate(matrix2, -obj.width / 2, -obj.height / 2);


                // Set rect for object to be rendered in
                atts.a_position = {
                    numComponents: 2,
                    data: new Float32Array(wgl.m3.setRectangle(0, 0, obj.width, obj.height))
                };
                // Sets texture coord - NOTE THIS SHOULD BE CHANGED FOR ARGUMENTS LATER FOR SPRITESHEETS
                atts.a_texCoord = {
                    numComponents: 2,
                    data: new Float32Array(wgl.setTextureCoord())
                };

                // actually setting up the unis and atts 
                for (let u in unis) {
                    if (setters.uni[u] === undefined) {
                        continue;
                    }
                    setters.uni[u](unis[u]);
                }
                for (let a in atts) {
                    if (setters.att[a] === undefined) {
                        continue;
                    }
                    setters.att[a](atts[a]);
                }
                gl.bindTexture(gl.TEXTURE_2D, obj.texture.texture);
                gl.drawArrays(obj.primitive, obj.offset, obj.count);
            }
            counter++;
            window.requestAnimationFrame(draw)
        }
    }
    wgl.loader(images, renderStart);
}
main();



</script>



    <style>

        canvas {
          border: 1px solid #FF0000;
          width: 100%;
          height: 100vh;
			image-rendering: optimizeSpeed;             /* STOP SMOOTHING, GIVE ME SPEED  */
			image-rendering: -moz-crisp-edges;          /* Firefox                        */
			image-rendering: -o-crisp-edges;            /* Opera                          */
			image-rendering: -webkit-optimize-contrast; /* Chrome (and eventually Safari) */
			image-rendering: pixelated; /* Chrome */
			image-rendering: optimize-contrast;         /* CSS3 Proposed                  */
			-ms-interpolation-mode: nearest-neighbor;   /* IE8+                           */
        }
        body {
        	background: black;
        }
    </style>
</body>
</html>



