<!DOCTYPE html>
<html>
    <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>title</title>
    </head>
    <body>
        <h1></h1>
        <text-canvas data-scale=1>
            Test no href
        </text-canvas>
        <text-canvas data-scale=3 href="#">
        This is some sample text. Now I just need to keep on typing and typing so it's longer than the screen to double check that it works. 
        </text-canvas>
        <text-canvas data-scale=4 href="#">
        More sample text.
        </text-canvas>
    </body>
    <script src="./temp.js" type="text/javascript"></script>
    
    <script id="vshader" type="vshader">
        uniform mat3 u_matrix;
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;    
        void main() {
            gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
            v_texCoord = a_texCoord;
        }
    </script>
    <script id="fgshader" type="fgshader">
        precision mediump float;
        uniform sampler2D u_image;
        uniform vec2 u_textureSize;
        varying vec2 v_texCoord;

        void main() {
            vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
            gl_FragColor =  texture2D(u_image, v_texCoord);
            float lumens = 0.2126 * gl_FragColor.r + 0.7152 * gl_FragColor.g + 0.0722 * gl_FragColor.b;
            float distance0 = distance(lumens, 0.0);
            float distance1 = distance(lumens, 1.0);
            if (gl_FragColor.a > 0.75) {
                gl_FragColor = vec4(0, 0, 0, 1);
            } else {
                gl_FragColor = vec4(0, 0, 0, 0);
            }
        }
    </script>
    
    <script>
        class TextCanvas extends HTMLElement {
            constructor(){
                super();
                const scaleFactor = parseInt(this.getAttribute("data-scale"))
                const shadow = this.attachShadow({mode: "open"});
                const linkWrapper = document.createElement("a");
                const canv = document.createElement("canvas");
                const canvgl = document.createElement("canvas");
                
                const ctx = canv.getContext("2d");
                const gl = canvgl.getContext("webgl", {antialias: false, premultipliedAlpha: true });
                
                let program = wgl.shadersToProgram(gl, document.getElementById("vshader").text, document.getElementById("fgshader").text);
                let setters = wgl.createSetters(gl, program);
                
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                gl.enable(gl.BLEND)
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.useProgram(program);
                
                const text = this.innerHTML.trim().split(" ");
                const style = document.createElement('style');
                
                canv.setAttribute("class", "canvasClass");
                canvgl.setAttribute("class", "canvgl");
                
                ctx.imageSmoothingEnabled = false;
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                                
                function resizeCanvas(){
                    ctx.canvas.width = canvgl.clientWidth / scaleFactor;
                    ctx.canvas.height = canvgl.clientHeight / scaleFactor;
                    gl.canvas.width = ctx.canvas.width;
                    gl.canvas.height = ctx.canvas.height;
                    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); 
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    // ideally the height should only be the height of the text inside
                    ctx.font = "13px Arial";
                    let line = "",
                        lines = [],
                        lineHeight = 13 * 1.54, // line-height standard calc
                        x = 0,
                        y = lineHeight; // line-height standard calc
                    for (var n=0; n < text.length; n++) {
                        let testLine = line + text[n] + ' ',
                            metrics = ctx.measureText(testLine), 
                            testWidth = metrics.width;
                        if (testWidth > ctx.canvas.width && n > 0) {
                            lines.push(line);
                            line = text[n] + ' ';
                            y += lineHeight;
                        }
                        else { line = testLine; }
                    }
                    lines.push(line);
                    for (let l in lines) {
                        ctx.fillText(lines[l], 0, lineHeight*(parseInt(l)+1));
                        ctx.fillText(lines[l], 0, lineHeight*(parseInt(l)+1));
                    }
                    
                    let texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, ctx.canvas)
                
                    
                    // gl rendering
                    let unis = {}, atts = {};
                    unis.u_textureSize = [ctx.canvas.width, ctx.canvas.height];
                    unis.u_matrix = wgl.m3.projection( gl.canvas.clientWidth, gl.canvas.clientHeight);
                    
                    atts.a_position = {numComponents: 2, data: new Float32Array(wgl.m3.setRectangle(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight))};
                    // Sets texture coord - NOTE THIS SHOULD BE CHANGED FOR ARGUMENTS LATER FOR SPRITESHEETS
                    atts.a_texCoord = {numComponents: 2, data: new Float32Array(wgl.setTextureCoord()) };
                    for (let u in unis){
                        if (setters.uni[u] === undefined){ continue; } 
                        setters.uni[u](unis[u]);
                    }
                    for (let a in atts){
                        if (setters.att[a] === undefined){ continue; } 
                        setters.att[a](atts[a]);
                    }
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }
                //    missing: u_matrix, u_umage, 
                
                new ResizeObserver(function(){ resizeCanvas(); }).observe(canvgl);
                
                style.textContent = `
                canvas { 
                    border: 1px solid red; 
                    width: 100%; 
                    height: 250px;
                    image-rendering: optimizeSpeed;             /* Older versions of FF          */
                    image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
                    image-rendering: -webkit-optimize-contrast; /* Safari                        */
                    image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
                    image-rendering: pixelated;                 /* Awesome future-browsers       */
                    -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
                }
                canvas:hover {
                    background: grey;
                }
                `;

                let link = this.getAttribute("href");
                shadow.appendChild(style);
                if (link !== null) {
                    linkWrapper.setAttribute("href", this.getAttribute("href"));
                    linkWrapper.append(canvgl);
                    shadow.appendChild(linkWrapper);
                } else { shadow.appendChild(canvgl) };
                
            }
        }
        
        customElements.define('text-canvas', TextCanvas);
    </script>
<!-- 
modernizr
    multilines...
    shadow dom...
    resize oberver

-->
</html>
