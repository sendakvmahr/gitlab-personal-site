<!DOCTYPE html>
<html>
    <head>
	    <meta charset="UTF-8">
	    <meta name="viewport" content="width=device-width,initial-scale=1">
	    <title>Sendak Mahr - Home</title>
        <script> const CAN_SHADOW = !!(document.head.attachShadow || document.head.createShadowRoot);</script>
	    <link href="./css/normalize.css" rel="stylesheet" type="text/css"></head>
	    <link href="./css/skeleton.css" rel="stylesheet" type="text/css"></head>
    </head>
    <body>
        <div class="container">
            <div class="row">
                <div class="sixteen columns">
                	<text-canvas data-scale=3 data-font="24px Times New Roman">
                		Sendak V. Mahr
                	</text-canvas>
                    
                    <!-- So I imagine two text areas, with premade tails sticking out
                    then positioning them based on the tails-->
                </div>
            </div>
            <div class="row">
                <div class="five columns">&nbsp;</div>
                <div class="menu six columns">
                    <text-canvas data-scale=3 data-font="13px Arial">
                        Test no href
                    </text-canvas> <!-- Make 12 the cutoff to use a pixel font" -->
                    <text-canvas data-scale=3 href="#" data-font="12px Arial">
                        This is some sample text. Now I just need to keep on typing and typing so it's longer than the screen to double check that it is working. 
                    </text-canvas>
                    <text-canvas data-scale=3 href="#" data-font="13px Arial">
                        More sample text.
                    </text-canvas>
                </div>
            </div>
        </div>
    </body>

    <script src="./js/util.js" type="text/javascript"></script>
    
    <script id="vshader" type="vshader">
        uniform mat3 u_matrix;
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;    
        void main() {
            gl_Position = vec4((u_matrix * vec3(a_position, 1)).xy, 0, 1);
            v_texCoord = a_texCoord;
        }
    </script>
    <script id="fgshader" type="fgshader">
        precision mediump float;
        uniform sampler2D u_image;
        uniform vec2 u_textureSize;
        varying vec2 v_texCoord;

        void main() {
            vec2 onePixel = vec2(1.0, 1.0) / u_textureSize;
            gl_FragColor =  texture2D(u_image, v_texCoord);
            float lumens = 0.2126 * gl_FragColor.r + 0.7152 * gl_FragColor.g + 0.0722 * gl_FragColor.b;
            float distance0 = distance(lumens, 0.0);
            float distance1 = distance(lumens, 1.0);
            if (gl_FragColor.a > 0.66) {
                gl_FragColor = vec4(0, 0, 0, 1);
            } else if (gl_FragColor.a > 0.33) {
                gl_FragColor = vec4(0, .1, .2, 0.7);
         	} else {
                gl_FragColor = vec4(0, 0, 0, 0);
            }
        }
    </script>
    
    <script>
    if (CAN_SHADOW) {
        class TextCanvas extends HTMLElement {
            constructor(){
                super();
                const scaleFactor = parseInt(this.getAttribute("data-scale"))
                const shadow = this.attachShadow({mode: "open"});
                const linkWrapper = document.createElement("a");
                const canv = document.createElement("canvas");
                const canvgl = document.createElement("canvas");
                const font = this.getAttribute("data-font");
                
                const ctx = canv.getContext("2d");
                const gl = canvgl.getContext("webgl", {antialias: false, premultipliedAlpha: true });
                
                const program = wgl.shadersToProgram(gl, document.getElementById("vshader").text, document.getElementById("fgshader").text);
                const setters = wgl.createSetters(gl, program);
                
                const text = this.innerHTML.trim().split(" ");
                const style = document.createElement('style');
                canvgl.setAttribute("aria-label", this.innerHTML.trim());
                
                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
                gl.enable(gl.BLEND)
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                gl.useProgram(program);
                ctx.imageSmoothingEnabled = false;
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                
                
                
                function resizeCanvas(){
                    ctx.canvas.width = canvgl.clientWidth / scaleFactor;
                    ctx.canvas.height = canvgl.clientHeight / scaleFactor;
                    gl.canvas.width = ctx.canvas.width;
                    gl.canvas.height = ctx.canvas.height;
                    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); 
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    ctx.font = font;
                    let line = "",
                        lines = [],
                        lineWidths = [],
                        lineHeight = 13 * 1.54; // line-height standard calc; 
                    for (var n=0; n < text.length; n++) {
                        let testAdd = text[n] + " ",
                            testLine = line + testAdd;
                        if (ctx.measureText(testLine).width > ctx.canvas.width && n > 0) {
                            lines.push(line);
                            lineWidths.push(ctx.measureText(line).width);
                            line = testAdd;
                        }
                        else { line = testLine; }
                    }
                    lineWidths.push(ctx.measureText(line).width)
                    lines.push(line);
                    for (let l = 0; l < lines.length; l++) {
                        let x = (ctx.canvas.width - lineWidths[l])/2,
                            y = lineHeight*(parseInt(l)+1);
                        ctx.fillText(lines[l], x, y);
                        ctx.fillText(lines[l], x, y);
                    }
                    canvgl.style.height = (lineHeight * (lines.length + .5)) * scaleFactor + "px";
                    let texture = gl.createTexture();
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, ctx.canvas)
                
                    
                    // gl rendering
                    let unis = {}, atts = {};
                    unis.u_textureSize = [ctx.canvas.width, ctx.canvas.height];
                    unis.u_matrix = wgl.m3.projection( gl.canvas.clientWidth, gl.canvas.clientHeight);
                    
                    atts.a_position = {numComponents: 2, data: new Float32Array(wgl.m3.setRectangle(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight))};
                    // Sets texture coord - NOTE THIS SHOULD BE CHANGED FOR ARGUMENTS LATER FOR SPRITESHEETS
                    atts.a_texCoord = {numComponents: 2, data: new Float32Array(wgl.setTextureCoord()) };
                    for (let u in unis){
                        if (setters.uni[u] === undefined){ continue; } 
                        setters.uni[u](unis[u]);
                    }
                    for (let a in atts){
                        if (setters.att[a] === undefined){ continue; } 
                        setters.att[a](atts[a]);
                    }
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.drawArrays(gl.TRIANGLES, 0, 6);
                }
                
                new ResizeObserver(function(){ resizeCanvas(); }).observe(canvgl);
                
                style.textContent = `
                canvas { 
                    width: 100%; 
                    image-rendering: optimizeSpeed;             /* Older versions of FF          */
                    image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
                    image-rendering: -webkit-optimize-contrast; /* Safari                        */
                    image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
                    image-rendering: pixelated;                 /* Awesome future-browsers       */
                    -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
                }
                canvas:hover {
                    background: grey;
                }
                `;

                let link = this.getAttribute("href");
                shadow.appendChild(style);
                if (link !== null) {
                    linkWrapper.setAttribute("href", this.getAttribute("href"));
                    linkWrapper.append(canvgl);
                    shadow.appendChild(linkWrapper);
                } else { shadow.appendChild(canvgl) };
            }
        }
        customElements.define('text-canvas', TextCanvas);
    } else {
        //fallback css
        var head = document.getElementsByTagName('HEAD')[0];  
        var link = document.createElement('link'); 
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './text-canvas-fallback.css';
        head.appendChild(link);
    }
    </script>
    <style>
    * {
        image-rendering: optimizeSpeed;             /* Older versions of FF          */
        image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
        image-rendering: -webkit-optimize-contrast; /* Safari                        */
        image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
        image-rendering: pixelated;                 /* Awesome future-browsers       */
        -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
    }
    </style>
<!-- 
modernizr
    multilines...
    shadow dom...
    resize oberver

-->
</html>
